// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: organizations.sql

package pgstore

import (
	"context"
	"fmt"
	"vivaop/internal/entities/organizationentity"
	"vivaop/internal/usecases/app/repos/organizationrepo"

	"github.com/google/uuid"
)

const addRegistrationImage = `-- name: AddRegistrationImage :one
UPDATE organizations
SET registration_image = $1,
    updated_at        = NOW()
WHERE id = $2
RETURNING id, name, country_id, owner_id, registration_code, registration_date, registration_image, verified, created_at, updated_at, deleted_at
`

func (q *Queries) AddRegistrationImage(ctx context.Context, params *organizationrepo.UploadOrganizationParams) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, addRegistrationImage, params.UploadURL, params.ID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
		UpdatedAt:         i.UpdatedAt.Time,
		DeletedAt:         i.DeletedAt.Time,
	}, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations
(id,
 name,
 country_id,
 owner_id,
 verified,
 registration_code,
 registration_date)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, country_id, owner_id, registration_code, registration_date, registration_image, verified, created_at, updated_at, deleted_at
`

func (q *Queries) CreateOrganization(ctx context.Context, arg *organizationrepo.CreateOrganizationParams) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganization,
		arg.ID,
		arg.Name,
		arg.CountryID,
		arg.OwnerID,
		arg.Verified,
		arg.RegistrationCode,
		arg.RegistrationDate,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
	}, err
}

const deleteOrganization = `-- name: DeleteOrganization :one
UPDATE organizations
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, country_id, owner_id, verified, registration_code, registration_date, registration_image, created_at, updated_at, deleted_at
`

func (q *Queries) DeleteOrganization(ctx context.Context, id uuid.UUID) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, deleteOrganization, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.Verified,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
		UpdatedAt:         i.UpdatedAt.Time,
		DeletedAt:         i.DeletedAt.Time,
	}, err
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, name, country_id, owner_id, verified, registration_code, registration_date, registration_image, created_at, updated_at, deleted_at
FROM organizations
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetOrganization(ctx context.Context, id uuid.UUID) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganization, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.Verified,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
		UpdatedAt:         i.UpdatedAt.Time,
		DeletedAt:         i.DeletedAt.Time,
	}, err
}

const getOrganizationByOwner = `-- name: GetOrganizationByOwner :one
SELECT id, name, country_id, owner_id, verified, registration_code, registration_date, registration_image, created_at, updated_at, deleted_at
FROM organizations
WHERE id = $1
  AND owner_id = $2
LIMIT 1
`

func (q *Queries) GetOrganizationByOwner(ctx context.Context, arg *organizationrepo.GetOrganizationByOwnerParams) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByOwner, arg.ID, arg.OwnerID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.Verified,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
		UpdatedAt:         i.UpdatedAt.Time,
		DeletedAt:         i.DeletedAt.Time,
	}, err
}

const listOwnerOrganization = `-- name: ListOwnerOrganization :many
SELECT id, name, country_id, owner_id, verified, registration_code, registration_date, registration_image, created_at, updated_at, deleted_at
FROM organizations
WHERE owner_id = $1 AND deleted_at IS NULL
`

func (q *Queries) ListOwnerOrganization(ctx context.Context, ownerID uuid.UUID) ([]*organizationentity.Organization, error) {
	rows, err := q.db.QueryContext(ctx, listOwnerOrganization, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*organizationentity.Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountryID,
			&i.OwnerID,
			&i.Verified,
			&i.RegistrationCode,
			&i.RegistrationDate,
			&i.RegistrationImage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		org := &organizationentity.Organization{
			ID:                i.ID,
			Name:              i.Name,
			CountryID:         i.CountryID,
			OwnerID:           i.OwnerID,
			Verified:          i.Verified,
			RegistrationCode:  i.RegistrationCode,
			RegistrationDate:  i.RegistrationDate,
			RegistrationImage: i.RegistrationImage.String,
			CreatedAt:         i.CreatedAt,
			UpdatedAt:         i.UpdatedAt.Time,
			DeletedAt:         i.DeletedAt.Time,
		}
		items = append(items, org)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrganization = `-- name: SearchOrganization :many
SELECT id, name, country_id, owner_id, registration_code, registration_date, registration_image, verified, created_at, updated_at, deleted_at
FROM organizations
WHERE name ILIKE $1  AND verified = true
  AND deleted_at IS NULL
`

func (q *Queries) SearchOrganizations(ctx context.Context, query string) ([]*organizationentity.Organization, error) {
	rows, err := q.db.QueryContext(ctx, searchOrganization, fmt.Sprintf("%%%s%%", query))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*organizationentity.Organization{}
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountryID,
			&i.OwnerID,
			&i.RegistrationCode,
			&i.RegistrationDate,
			&i.RegistrationImage,
			&i.Verified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		org := &organizationentity.Organization{
			ID:                i.ID,
			Name:              i.Name,
			CountryID:         i.CountryID,
			OwnerID:           i.OwnerID,
			Verified:          i.Verified,
			RegistrationCode:  i.RegistrationCode,
			RegistrationDate:  i.RegistrationDate,
			RegistrationImage: i.RegistrationImage.String,
			CreatedAt:         i.CreatedAt,
			UpdatedAt:         i.UpdatedAt.Time,
			DeletedAt:         i.DeletedAt.Time,
		}
		items = append(items, org)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE organizations
SET name              = $2,
    country_id        = $3,
    owner_id          = $4,
    verified          = $5,
    registration_code = $6,
    registration_date = $7,
    updated_at        = NOW()
WHERE id = $1
RETURNING id, name, country_id, owner_id, registration_code, registration_date, registration_image, verified, created_at, updated_at, deleted_at
`

func (q *Queries) UpdateOrganization(ctx context.Context, arg *organizationrepo.UpdateOrganizationParams) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, updateOrganization,
		arg.ID,
		arg.Name,
		arg.CountryID,
		arg.OwnerID,
		arg.Verified,
		arg.RegistrationCode,
		arg.RegistrationDate,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
		UpdatedAt:         i.UpdatedAt.Time,
		DeletedAt:         i.DeletedAt.Time,
	}, err
}

const verifyOrganization = `-- name: VerifyOrganization :one
UPDATE organizations
SET verified   = true,
	updated_at = NOW()
WHERE id = $1
RETURNING id, name, country_id, owner_id, registration_code, registration_date, registration_image, verified, created_at, updated_at, deleted_at
`

func (q *Queries) VerifyOrganization(ctx context.Context, orgID uuid.UUID) (*organizationentity.Organization, error) {
	row := q.db.QueryRowContext(ctx, verifyOrganization, orgID)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryID,
		&i.OwnerID,
		&i.RegistrationCode,
		&i.RegistrationDate,
		&i.RegistrationImage.String,
		&i.Verified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &organizationentity.Organization{
		ID:                i.ID,
		Name:              i.Name,
		CountryID:         i.CountryID,
		OwnerID:           i.OwnerID,
		Verified:          i.Verified,
		RegistrationCode:  i.RegistrationCode,
		RegistrationDate:  i.RegistrationDate,
		RegistrationImage: i.RegistrationImage.String,
		CreatedAt:         i.CreatedAt,
		UpdatedAt:         i.UpdatedAt.Time,
		DeletedAt:         i.DeletedAt.Time,
	}, err
}
